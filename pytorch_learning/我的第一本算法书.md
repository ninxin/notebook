### 数据结构

##### 链表

数据线性排列，添加删除较方便，访问较费时间

数据一般分散存储与内存中，不需存储在连续空间

访问数据只能从第一个数据开始，顺着指针的指向一一向下访问（顺序访问）

添加数据只需改变添加位置前后的指针指向就行

删除也一样

###### 循环链表

在普通链表尾部使用指针，指向头部数据，变为环形

没有头和尾的概念

保存数量固定的最新数据时通常会使用

###### 双向链表

普通链表每个数据只有一个指针。现在设为两个，分别指向前后数据，

这样不仅可以从前到后，也可以从后到前遍历数据

**缺点**：指针数的增加会导致存储空间需求增加，添加和删除数据需要改变更多指针的指向



##### 数组

线性排列，访问数据十分简单

添加删除较耗时间，操作比链表复杂

首先，在数组的末尾确保有足够的空间，为了给新数据腾出位置，将数据一个个后移，最后在空的空间上添加

按顺序存储在连续空间，所以每个数据的内存地址可以通过下标算出，就可以直接访问（随机访问）



##### 栈

线性排列，只能访问最后添加的数据，后进先出LIFO

添加删除的操作只能在一端进行，访问数据只能访问顶端的数据，

想要访问中间的数据需要出栈，将上面的数据移出



通常应用在只需访问最新数据

比如：匹配括号，（ ABC ( F ( G ))）

从左边读取，遇到（ 就入栈，遇到 ）就出栈

在深度优先搜索算法，通常选择最新的数据作为候补顶点，在候补顶点的管理上就可以用**栈**



##### 队列

线性排列，先进先出FIFO

添加删除在两端进行，也不能直接访问中间数据，需要先出队



在广度优先搜索算法，通常从搜索候补中选择最早的数据作为下一个顶点，

可以使用**队列**管理候补顶点



##### 哈希表

存储键值对数据，在这种结构中使用**哈希函数**可使数据的查询效率显著提升

**存储**：先用哈希函数计算数据的键，也就是它的哈希值，然后将得到的哈希值除以所要存储**数组**的长度，

求其余数，余数为几就在第几个表中。如果**数组**中已有数据，则存储位置重复（哈希冲突），可在原有数据后使用链表，继续存储新的数据（**链地址法**，还有其他方法）

**查询**：想要查询数据的值，先计算这个键的哈希值，再除以**数组**长，求余得到所在的**数组**，

然后查看这个表，找到和这个键一样的（如果第一个不一样，则在此链表中线性查找），再取出对应的值



数组空间小，则容易发生冲突，线性查找使用频率高

数组空间大，内存浪费



**开放地址法**：发生冲突时，计算一个候补地址（数组上的位置），将其存入，若还冲突，

继续计算，直到有空地址为止。可以通过多次使用**哈希函数**或**线性探测法**等方法计算候补地址



##### 堆

是一种图的树形结构，用于实现**优先队列**

优先队列是一种数据结构，可自由添加数据，但取出时要从最小值开始按顺序取出。

**存储**：子节点大于父节点。所以最小值存储在顶端的根节点。

添加数据时，为遵守此规则，一般将新数据放到最下面一行靠左的位置，如果最后一行没有多余空间则另起一行，放在最左端。

如果比父节点小，则互换位置，一直重复知道所有数据都满足

**取出**：取出数据时，取出的是最上面的数据。这样才能始终保持最上面的数据最小。

取出后，结构发生改变。将最后的数据移到最顶端，然后比较。若大于子节点，则和子结点中较小的一个进行交换，重复操作。



取出最小值的时间复杂度为O(1),然后需要重构树，假设数据量为n，树的高度则为log~2~n

则重构数的时间复杂度为O(logn)

添加也是一样

**应用**：需要频繁的从数据中取出最小值。狄克斯拉特算法，每一步都要从候补顶点中选择距离起点最近的顶点。



##### 二叉查找树

二叉搜索树，二叉排序树

采用图的树形结构，数据存储在节点上

每个结点的值都大于其左子树上任意节点的值

每个结点的值都小于其右子树上任意节点的值

所以最小值在最左端，最大值在最右端

**添加**：从顶端节点开始寻找位置。与该节点比较，小于则往左移，大于则往右移，直到没有节点为止，然后作为新结点添加上

**删除**：若无子节点，直接删除。一个子节点，则直接删除后，子节点移到删除节点的位置。

若有两个子节点，先删除，再从被删除节点的左子树上找到最大节点代替（由性质知，右节点最小值也行）。

**查找**：从顶端往下找，和添加类似

平衡二叉树：修正形状不均衡的树，让其始终保持均衡形态，提高查找效率





### 排序

##### 冒泡排序

O(n^2^)

从序列右边开始比较相邻的两个数字大小，根据结果是否交换两个个数字的位置。

在此过程中，数字像泡泡一样从右浮到左边

在第一轮需要比较n-1次，最后一轮也就是n-1轮比较1次

所以总次数约为n^2^/2,这个次数和数据的排列顺序无关，交换数字的次数和排列顺序有关



##### 选择排序

O(n^2^)

从待排序数据中寻找最小值，将其与序列最左边的值交换，然后再从剩下n-1个数中重复

第一轮比较n-1次，第n-1轮比较1次，所以比较次数和冒泡排序相同

每轮交换次数最多为1次



##### 插入排序

从左端依次对数据排序，左边的数据陆续归位，右边留下的是未排序数据，将右侧未被排序数据依次插入到已排序的合适位置

首先将左边第一个数据视为排序好的，将第二个数据和他比较，大于则不变，小于则交换位置

然后前两个为排序好的数据，用第三个数据先和第二个数据比较，如果大于则不变，小于则继续和第一个数据比较，若大于则和第二个数据交换，小于则和第一个数据交换……

第一轮比较1次，第k轮最对比较k-1次，所以最坏情况下时间复杂度和冒泡排序一样，为**O(n^2^)**

数据从大到小排列为最坏情况



##### 堆排序

先在堆中存储所有数据，降序构建堆，为了排序，再一个个从堆中取出数据

从降序排列的堆中取数据会从最大的开始取，所以将取出的数据反序数据，排列就完成了

将数据存在堆中时间复杂度为O(nlogn)：排序过程中，堆从空堆开始，由于堆的高度小于logn，所以插入一个数据的时间为O(logn)

每轮取出数据并重构堆需要O(logn),一共n轮，所以重构后排序也是O(nlogn)

所以总体来看堆排序时间复杂度为**O(nlogn)**，这样看运行时间更短，但要使用堆这个相对复杂的数据结构，所以实现起来较为困难。



##### 归并排序

将序列分成两个长度相同的子序列，再将子序列分，直到无法再分为止，也就是每个子序列只有一个数据。然后堆子序列归并

归并是指将两个排好序的子序列合并成一个有序序列，一直重复直到所有子序列归并到一个整体。

分割序列所费的时间不算在运行时间内。合并两个子序列时，只需重复比较首位数据的大小，然后移动小的数据，

所以只需花费和两个子序列长度的运行时间，也就是说完成一行归并花费的时间取决于这一行的数据量

总运行时间为**O(nlogn)**



##### 快速排序

（分治法：将原本问题分成两个子问题）

首先随机在序列中选择一个基准值，将其他的数分为大于基准值的数和小于基准值的数，

再对这两个序列重复操作，直到这个序列中只有一个数据为止。

在算法内部继续调用该算法，递归



如果每次选择的基准值都能使两个子序列的长度一样，那么快速排序的运行时间和归并排序一样为**O(nlogn)**

若运气不好，每次基准值为最小值，那运行时间为**O(n^2^)**,相当于每次选出最小值移到左边，和选择排序一样。

平均时间为**O(nlogn)**



### 数组的查找

##### 线性查找

**O(n)**

从头开始按顺序查找，当数据量大且目标数据靠后，或者目标数据不存在，比较的次数更多更耗时。



##### 二分查找

**O(logn)**

只能查找排好序的数据。

通过比较中间数据和目标数据的大小，来确定是在左边还是在右边，重复操作。



二分查找需要排好序，因此添加数据时必须加到合适的位置，这需要额外耗费维护数组的时间

线性查找可以是无序的，添加数据无需考虑位置，直接加到末尾即可。

具体使用哪种方法可以根据查找和添加哪个操作更频繁来决定



### 图的搜索

最短路径问题

##### 广度优先搜索

对图搜索

从起点开始顺着边搜索，直到到达指定顶点。在此过程中每到一个顶点都会判断是否为终点。

优先从离起点近的顶点搜索



从起点开始，将他可以直接到达的顶点放入管理候补顶点的队列中（先进先出），按顺序拿出一个顶点，

判断它是否为终点，不是则出队，并将它可直达的顶点作为候补顶点入队，然后再从队列中按顺序拿出，重复下去，

直到找到终点



从起点开始，由近及远，目标越近则越快

##### 深度优先搜索

对图搜索

沿着一条路径一直搜索直到不能继续为止，然后折返，搜索下一条候补路径



从起点出发，将可直达的顶点设为候补顶点，放入栈中（先入后出）。按顺序拿出一个顶点，

判读是否为终点，不是则将他可直达的顶点放入栈中，继续下去。如果到了路径尽头则折返，将顶点出栈。







